#Load data in R environment
##################
library(tidyverse)
library(vegan)
#library(RColorBrewer)
#library(gridExtra)
##################
#Directory paths
##################
to.data <- "./data/"
to.script <- "./scripts/"
to.output <- "./output/"
to.figs <- "./figs/"
to.R <- "./output/"
##################
#Load data in R environment
##################
data = readRDS(paste0(to.output,"cl.data.RDS"))
# Filter data (bacteria were only measured for replicates A and B)
X <- data %>%
filter(day!=0 & Replicate %in% c("A","B")) %>%
mutate(Treatment = as.factor(Treatment),
day = factor(day,levels=c("0","7","15","21","29")),
day.cont = log(as.numeric(as.character(day))),
Size = as.ordered(Size),
centrality = as.numeric(as.character(centrality)),
dist.outlet = as.numeric(as.character(dist.outlet)))
# Run model
Mod1 <- nlme:::lme(log(bact.blue) ~ Size*Treatment + bact.green + day.cont,
random = ~ day|Replicate, data=X,
method="ML",control=lmeControl(optimMethod="BFGS",maxIter=100,opt="optim"))
summary(Mod1)$tTable
# Filter data (bacteria were only measured for replicates A and B)
X1 <- data %>%
filter(day!=0 & Replicate %in% c("A","B")) %>%
mutate(Treatment = as.factor(Treatment),
day = factor(day,levels=c("0","7","15","21","29")),
day.cont = log(as.numeric(as.character(day))),
Size = as.numeric(as.character(Size)),
centrality = as.numeric(as.character(centrality)),
dist.outlet = as.numeric(as.character(dist.outlet)))
# Generate data frame with each predictor to extract predictions
newdat <-  with(X,
expand.grid(Treatment=unique(Treatment),
Size = c(min(Size),max(Size)),
bact.green=c(min(bact.green),max(bact.green)),
day.cont = c(min(day.cont),max(day.cont)))
)
# Run model
Mod1.1 <- nlme:::lme(log(bact.blue) ~ Size*Treatment + bact.green + day.cont,
random = ~ day|Replicate, data=X,
method="ML",control=lmeControl(optimMethod="BFGS",maxIter=100,opt="optim"))
ggplot(mapping=aes(x=Size,y=log(bact.blue)),data=X) +
geom_point(col="blue",alpha=0.5) +
geom_line(data=newdat,aes(y=predict(Mod1.1,newdata=newdat,level=0)),col="red") -> p1
ggplot(mapping=aes(x=Treatment,y=log(bact.blue)),data=X) +
geom_boxplot(col="blue",alpha=0.5) -> p2
ggplot(mapping=aes(x=day.cont,y=log(bact.blue)),data=X) +
geom_point(col="blue",alpha=0.5) +
geom_line(data=newdat,aes(y=predict(Mod1.1,newdata=newdat,level=0)),col="red") -> p3
grid.arrange(p1,p2,p3,ncol=3)
library(gridExtra)
ggplot(mapping=aes(x=Size,y=log(bact.blue)),data=X) +
geom_point(col="blue",alpha=0.5) +
geom_line(data=newdat,aes(y=predict(Mod1.1,newdata=newdat,level=0)),col="red") -> p1
ggplot(mapping=aes(x=Treatment,y=log(bact.blue)),data=X) +
geom_boxplot(col="blue",alpha=0.5) -> p2
ggplot(mapping=aes(x=day.cont,y=log(bact.blue)),data=X) +
geom_point(col="blue",alpha=0.5) +
geom_line(data=newdat,aes(y=predict(Mod1.1,newdata=newdat,level=0)),col="red") -> p3
grid.arrange(p1,p2,p3,ncol=3)
predict(Mod1.1,newdata=newdat,level=0)
head(X1)
newdat
# Filter data (bacteria were only measured for replicates A and B)
X1 <- data %>%
filter(day!=0 & Replicate %in% c("A","B")) %>%
mutate(Treatment = as.factor(Treatment),
day = factor(day,levels=c("0","7","15","21","29")),
day.cont = log(as.numeric(as.character(day))),
Size = as.numeric(as.character(Size)),
centrality = as.numeric(as.character(centrality)),
dist.outlet = as.numeric(as.character(dist.outlet)))
# Generate data frame with each predictor to extract predictions
newdat <-  with(X1,
expand.grid(Treatment=unique(Treatment),
Size = c(min(Size),max(Size)),
bact.green=c(min(bact.green),max(bact.green)),
day.cont = c(min(day.cont),max(day.cont)))
)
# Run model
Mod1.1 <- nlme:::lme(log(bact.blue) ~ Size*Treatment + bact.green + day.cont,
random = ~ day|Replicate, data=X,
method="ML",control=lmeControl(optimMethod="BFGS",maxIter=100,opt="optim"))
ggplot(mapping=aes(x=Size,y=log(bact.blue)),data=X) +
geom_point(col="blue",alpha=0.5) +
geom_line(data=newdat,aes(y=predict(Mod1.1,newdata=newdat,level=0)),col="red") -> p1
ggplot(mapping=aes(x=Treatment,y=log(bact.blue)),data=X) +
geom_boxplot(col="blue",alpha=0.5) -> p2
ggplot(mapping=aes(x=day.cont,y=log(bact.blue)),data=X) +
geom_point(col="blue",alpha=0.5) +
geom_line(data=newdat,aes(y=predict(Mod1.1,newdata=newdat,level=0)),col="red") -> p3
grid.arrange(p1,p2,p3,ncol=3)
newdat
predict(Mod1.1,newdata=newdat,level=0)
head(X1)
# Filter data (bacteria were only measured for replicates A and B)
X1 <- data %>%
filter(day!=0 & Replicate %in% c("A","B")) %>%
mutate(Treatment = as.factor(Treatment),
day = factor(day,levels=c("0","7","15","21","29")),
day.cont = log(as.numeric(as.character(day))),
Size = as.numeric(as.character(Size)),
centrality = as.numeric(as.character(centrality)),
dist.outlet = as.numeric(as.character(dist.outlet)))
# Generate data frame with each predictor to extract predictions
newdat <-  with(X1,
expand.grid(Treatment=unique(Treatment),
Size = c(min(Size),max(Size)),
bact.green=c(min(bact.green),max(bact.green)),
day.cont = c(min(day.cont),max(day.cont)))
)
# Run model
Mod1.1 <- nlme:::lme(log(bact.blue) ~ Size*Treatment + bact.green + day.cont,
random = ~ day|Replicate, data=X1,
method="ML",control=lmeControl(optimMethod="BFGS",maxIter=100,opt="optim"))
ggplot(mapping=aes(x=Size,y=log(bact.blue)),data=X) +
geom_point(col="blue",alpha=0.5) +
geom_line(data=newdat,aes(y=predict(Mod1.1,newdata=newdat,level=0)),col="red") -> p1
ggplot(mapping=aes(x=Treatment,y=log(bact.blue)),data=X) +
geom_boxplot(col="blue",alpha=0.5) -> p2
ggplot(mapping=aes(x=day.cont,y=log(bact.blue)),data=X) +
geom_point(col="blue",alpha=0.5) +
geom_line(data=newdat,aes(y=predict(Mod1.1,newdata=newdat,level=0)),col="red") -> p3
grid.arrange(p1,p2,p3,ncol=3)
ggplot(mapping=aes(x=Size,y=log(bact.blue)),data=X1) +
geom_point(col="blue",alpha=0.5) +
geom_line(data=newdat,aes(y=predict(Mod1.1,newdata=newdat,level=0)),col="red") -> p1
ggplot(mapping=aes(x=Treatment,y=log(bact.blue)),data=X1) +
geom_boxplot(col="blue",alpha=0.5) -> p2
ggplot(mapping=aes(x=day.cont,y=log(bact.blue)),data=X1) +
geom_point(col="blue",alpha=0.5) +
geom_line(data=newdat,aes(y=predict(Mod1.1,newdata=newdat,level=0)),col="red") -> p3
grid.arrange(p1,p2,p3,ncol=3)
min(X$prot.ab)
X <- data %>%
filter(day!=0 & Replicate %in% c("A","B")) %>%
mutate(Treatment = as.factor(Treatment),
day = factor(day,levels=c("0","7","15","21","29")),
day.cont = as.numeric(as.character(day)),
Size = as.ordered(Size),
centrality = as.numeric(as.character(centrality)),
dist.outlet = as.numeric(as.character(dist.outlet)))
Mod2 <- nlme:::lme(prot.ab ~ Size*Treatment + bact.green + day.cont, random = ~ day|Replicate, data=X,
method="ML",control=lmeControl(optimMethod="BFGS",maxIter=100,opt="optim"))
hist(Mod2$residuals,breaks=50)
summary(Mod2)$tTable
ggplot(mapping=aes(x=Size,y=prot.ab),data=X) +
geom_boxplot(col="blue",alpha=0.5)
ggplot(mapping=aes(x=Size,y=prot.ab),data=X) +
geom_boxplot(col="blue",alpha=0.5) +
facet_wrap(~Treatment)
##################
#Load data in R environment
##################
library(tidyverse)
library(vegan)
#library(RColorBrewer)
library(gridExtra)
##################
#Directory paths
##################
to.data <- "./data/"
to.script <- "./scripts/"
to.output <- "./output/"
to.figs <- "./figs/"
to.R <- "./output/"
##################
#Load data in R environment
##################
data = readRDS(paste0(to.output,"cl.data.RDS"))
##################
# Ordination (temporal trends in community structure)
##################
#Create interaction variable
data$Treat.Size <- interaction(data$Treatment,data$Size)
data$Treat.Day <- interaction(data$Treatment,data$day)
data$Treat.Size.Day <- interaction(data$Treatment,data$Size,data$day)
#Place vars of interest into vectors for each component of ordination
SP <- c("Rot","Spi","Ble","Pca","Col","Chi","Tet","Other") #comm matrix
ENV <- c("day.cont","centrality","Size","dist.outlet","Treatment","Treat.Size","Treat.Size.Day") #Constrains
CONT <- c("Replicate") #Effect to partial out
#Filter data as wanted (for bacteria need to use only rep A and B)
X <- data %>%
filter(day!=0 & Replicate %in% c("A","B","C","D")) %>%
mutate(Treatment = as.factor(Treatment),
day = factor(day,levels=c("0","7","15","21","29")),
day.cont = as.numeric(as.character(day)),
Size = as.ordered(Size),
centrality = as.numeric(as.character(centrality)),
dist.outlet = as.numeric(as.character(dist.outlet)))
#Create matrices for analyses
C <- decostand(X[,SP],"hell")
E <- X[,ENV]
Z <- as.matrix(X[,CONT])
head(C)
head(E)
rda.mod <- rda(C ~ ., as.data.frame(E))
rda.mod
anova(rda.mod,by="terms",permu=200)
library(RColorBrewer)
##define color vector
#display.brewer.all(nlevels(X$Treat.Size))
colvec <- brewer.pal(nlevels(as.factor(X$Treatment)),"Dark2")
#pchvec <- c(16,17,21)
##Plot
ordiplot(rda.mod,display="site",type="n",xlim=c(-1.5,1.5))
#text(rda.mod, display="cn", col="blue",cex=0.5)
points(rda.mod, display="site", cex=0.5,pch=21,col=colvec[X$Treatment])
text(rda.mod, display="sp", col="blue",cex=1)
legend("bottomleft",legend=levels(X$Treatment),col=colvec,pch=16,bty="n",cex=0.5)
##Plot predictors
ordiplot(rda.mod,display="site",type="n",xlim=c(-1.5,1.5))
text(rda.mod, display="cn", col="blue",cex=0.5)
text(rda.mod, display="sp", col="blue",cex=1)
####Generate data for LRR calculation
D <- data %>%
filter(day !=0)
####Create vectors with variables of interest
t <- c("7","15","21","29")
SP <- c("Rot","Spi","Ble","Pca","Col","Chi","Tet","Other")
S <- c("7.5","13.0","22.5","45.0")
####Replace zeros by the same very small value (to avoid INF and -INF in log ratio)
min = 0.001
D[,SP] <- lapply(D[,SP],function(x) ifelse(x==0,min,x))
####Calculate LRR
output <- data.frame(time=character(0),size=character(0),LRR=numeric(0),SP=character(0))#[1:(144*length(SP)),]
for(i in 1:length(t)){
for(j in 1:length(SP)) {
LRR <- log( D[which(D$Treatment=="Connected" & D$day==t[i]),SP[j]] / D[which(D$Treatment=="Isolated" & D$day==t[i]),SP[j]] )
species <- rep(SP[j],144)
time <- rep(t[i],144)
size <- D$Size[which(D$Treatment=="Connected" & D$day==t[i])]
lala <- cbind(time,size,LRR,species)
colnames(lala) <- c("time","size","LRR","species")
output <- rbind.data.frame(output,lala)
}
}
dat.lrr <- output %>%
filter(time!=0) %>%
group_by(species) %>%
summarise(mean.lrr = mean(LRR, na.rm=TRUE),
CI = qnorm(0.975) * ( sd(LRR) / sqrt(length(LRR)) ) )
plot(NA,xlim=c(1,8),ylim=c(-2,2),xlab="Species",ylab="ln(patch connected / patch isolated)",xaxt="n")
axis(1,at=1:8,labels=dat.lrr$species)
abline(h=0,lty=3)
arrows(1:8,dat.lrr$mean.lrr + dat.lrr$CI,1:8, dat.lrr$mean.lrr - dat.lrr$CI,angle=90,code=3,length=0.05)
points(dat.lrr$species,dat.lrr$mean.lrr,pch=16)
dat.lrr2 <- output %>%
filter(time!=0) %>%
group_by(size,species) %>%
summarise(mean.lrr = mean(LRR, na.rm=TRUE),
CI = qnorm(0.975) * ( sd(LRR) / sqrt(length(LRR)) ) )
S <- c(7.5,13,22.5,45)
layout(matrix(1:4,ncol=2,nrow=2))
#par(mfrow=c(2,2))
for(i in 1:length(S)){
plot(NA,xlim=c(1,8),ylim=c(-4,3.5),main=paste(S[i],"mL"),xlab="Species",ylab="ln(patch connected / patch isolated)",xaxt="n")
axis(1,at=1:8,labels=SP)
abline(h=0,lty=3)
arrows(1:8,dat.lrr2$mean.lrr[dat.lrr2$size==S[i]] + dat.lrr2$CI[dat.lrr2$size==S[i]],1:8, dat.lrr2$mean.lrr[dat.lrr2$size==S[i]] - dat.lrr2$CI[dat.lrr2$size==S[i]],angle=90,code=3,length=0.05)
points(dat.lrr2$species[dat.lrr2$size==S[i]],dat.lrr2$mean.lrr[dat.lrr2$size==S[i]],pch=16)
}
####Generate data for LRR calculation
D <- data %>%
filter(day !=0 & Replicate %in% c("A","B"))
####Create vectors with variables of interest
t <- c("7","15","21","29")
S <- c("7.5","13.0","22.5","45.0")
####Calculate LRR
output <- data.frame(time=character(0),size=character(0),LRR=numeric(0))#[1:(144*length(SP)),]
for(i in 1:length(t)){
LRR <- log( D$bact.green[which(D$Treatment=="Connected" & D$day==t[i])] / D$bact.green[which(D$Treatment=="Isolated" & D$day==t[i])] )
time <- rep(t[i],72)
size <- D$Size[which(D$Treatment=="Connected" & D$day==t[i])]
lala <- cbind(time,size,LRR)
colnames(lala) <- c("time","size","LRR")
output <- rbind.data.frame(output,lala)
}
dat.lrr <- output %>%
mutate(LRR = as.numeric(as.character(LRR))) %>%
group_by(time) %>%
summarise(mean.lrr = mean(LRR, na.rm=TRUE),
CI = qnorm(0.975) * ( sd(LRR) / sqrt(length(LRR)) ) )
plot(NA,xlim=c(1,4),ylim=c(-1,1),xlab="Exp. time",ylab="ln(patch connected / patch isolated)",xaxt="n")
axis(1,at=1:4,labels=dat.lrr$time)
abline(h=0,lty=3)
arrows(1:4,dat.lrr$mean.lrr + dat.lrr$CI,1:4, dat.lrr$mean.lrr - dat.lrr$CI,angle=90,code=3,length=0.05)
points(dat.lrr$time,dat.lrr$mean.lrr,pch=16)
dat.lrr <- output %>%
filter(time==21) %>% #The previous graph showed that the effect if stronger at day 21
mutate(LRR = as.numeric(as.character(LRR))) %>%
group_by(size) %>%
summarise(mean.lrr = mean(LRR, na.rm=TRUE),
CI = qnorm(0.975) * ( sd(LRR) / sqrt(length(LRR)) ) )
plot(NA,xlim=c(1,4),ylim=c(-1.5,1.5),xlab="Patch size",ylab="ln(patch connected / patch isolated)",xaxt="n")
axis(1,at=1:4,labels=dat.lrr$size)
abline(h=0,lty=3)
arrows(1:4,dat.lrr$mean.lrr + dat.lrr$CI,1:4, dat.lrr$mean.lrr - dat.lrr$CI,angle=90,code=3,length=0.05)
points(dat.lrr$size,dat.lrr$mean.lrr,pch=16)
##################
#Load data in R environment
##################
library(tidyverse)
library(vegan)
library(RColorBrewer)
library(gridExtra)
##################
#Directory paths
##################
to.data <- "./data/"
to.script <- "./scripts/"
to.output <- "./output/"
to.figs <- "./figs/"
to.R <- "./output/"
##################
#Load data in R environment
##################
data = readRDS(paste0(to.output,"cl.data.RDS"))
##################
# Ordination (temporal trends in community structure)
##################
#Create interaction variable
data$Treat.Size <- interaction(data$Treatment,data$Size)
data$Treat.Day <- interaction(data$Treatment,data$day)
data$Treat.Size.Day <- interaction(data$Treatment,data$Size,data$day)
#Place vars of interest into vectors for each component of ordination
SP <- c("Rot","Spi","Ble","Pca","Col","Chi","Tet","Other") #comm matrix
ENV <- c("day.cont","centrality","Size","dist.outlet","Treatment","Treat.Size","Treat.Size.Day") #Constrains
CONT <- c("Replicate") #Effect to partial out
#Filter data as wanted (for bacteria need to use only rep A and B)
X <- data %>%
filter(day!=0 & Replicate %in% c("A","B","C","D")) %>%
mutate(Treatment = as.factor(Treatment),
day = factor(day,levels=c("0","7","15","21","29")),
day.cont = as.numeric(as.character(day)),
Size = as.ordered(Size),
centrality = as.numeric(as.character(centrality)),
dist.outlet = as.numeric(as.character(dist.outlet)))
#Create matrices for analyses
C <- decostand(X[,SP],"hell")
E <- X[,ENV]
Z <- as.matrix(X[,CONT])
head(C)
head(E)
rda.mod <- rda(C ~ ., as.data.frame(E))
rda.mod
##define color vector
#display.brewer.all(nlevels(X$Treat.Size))
colvec <- brewer.pal(nlevels(as.factor(X$Treatment)),"Dark2")
#pchvec <- c(16,17,21)
##Plot
ordiplot(rda.mod,display="site",type="n",xlim=c(-1.5,1.5))
#text(rda.mod, display="cn", col="blue",cex=0.5)
points(rda.mod, display="site", cex=0.5,pch=21,col=colvec[X$Treatment])
text(rda.mod, display="sp", col="blue",cex=1)
legend("bottomleft",legend=levels(X$Treatment),col=colvec,pch=16,bty="n",cex=0.5)
##Plot predictors
ordiplot(rda.mod,display="site",type="n",xlim=c(-1.5,1.5))
text(rda.mod, display="cn", col="blue",cex=0.5)
text(rda.mod, display="sp", col="blue",cex=1)
####Generate data for LRR calculation
D <- data %>%
filter(day !=0)
####Create vectors with variables of interest
t <- c("7","15","21","29")
SP <- c("Rot","Spi","Ble","Pca","Col","Chi","Tet","Other")
S <- c("7.5","13.0","22.5","45.0")
####Replace zeros by the same very small value (to avoid INF and -INF in log ratio)
min = 0.001
D[,SP] <- lapply(D[,SP],function(x) ifelse(x==0,min,x))
####Calculate LRR
output <- data.frame(time=character(0),size=character(0),LRR=numeric(0),SP=character(0))#[1:(144*length(SP)),]
for(i in 1:length(t)){
for(j in 1:length(SP)) {
LRR <- log( D[which(D$Treatment=="Connected" & D$day==t[i]),SP[j]] / D[which(D$Treatment=="Isolated" & D$day==t[i]),SP[j]] )
species <- rep(SP[j],144)
time <- rep(t[i],144)
size <- D$Size[which(D$Treatment=="Connected" & D$day==t[i])]
lala <- cbind(time,size,LRR,species)
colnames(lala) <- c("time","size","LRR","species")
output <- rbind.data.frame(output,lala)
}
}
dat.lrr <- output %>%
filter(time!=0) %>%
group_by(species) %>%
summarise(mean.lrr = mean(LRR, na.rm=TRUE),
CI = qnorm(0.975) * ( sd(LRR) / sqrt(length(LRR)) ) )
plot(NA,xlim=c(1,8),ylim=c(-2,2),xlab="Species",ylab="ln(patch connected / patch isolated)",xaxt="n")
axis(1,at=1:8,labels=dat.lrr$species)
abline(h=0,lty=3)
arrows(1:8,dat.lrr$mean.lrr + dat.lrr$CI,1:8, dat.lrr$mean.lrr - dat.lrr$CI,angle=90,code=3,length=0.05)
points(dat.lrr$species,dat.lrr$mean.lrr,pch=16)
dat.lrr2 <- output %>%
filter(time!=0) %>%
group_by(size,species) %>%
summarise(mean.lrr = mean(LRR, na.rm=TRUE),
CI = qnorm(0.975) * ( sd(LRR) / sqrt(length(LRR)) ) )
S <- c(7.5,13,22.5,45)
layout(matrix(1:4,ncol=2,nrow=2))
#par(mfrow=c(2,2))
for(i in 1:length(S)){
plot(NA,xlim=c(1,8),ylim=c(-4,3.5),main=paste(S[i],"mL"),xlab="Species",ylab="ln(patch connected / patch isolated)",xaxt="n")
axis(1,at=1:8,labels=SP)
abline(h=0,lty=3)
arrows(1:8,dat.lrr2$mean.lrr[dat.lrr2$size==S[i]] + dat.lrr2$CI[dat.lrr2$size==S[i]],1:8, dat.lrr2$mean.lrr[dat.lrr2$size==S[i]] - dat.lrr2$CI[dat.lrr2$size==S[i]],angle=90,code=3,length=0.05)
points(dat.lrr2$species[dat.lrr2$size==S[i]],dat.lrr2$mean.lrr[dat.lrr2$size==S[i]],pch=16)
}
####Generate data for LRR calculation
D <- data %>%
filter(day !=0 & Replicate %in% c("A","B"))
####Create vectors with variables of interest
t <- c("7","15","21","29")
S <- c("7.5","13.0","22.5","45.0")
####Calculate LRR
output <- data.frame(time=character(0),size=character(0),LRR=numeric(0))#[1:(144*length(SP)),]
for(i in 1:length(t)){
LRR <- log( D$bact.green[which(D$Treatment=="Connected" & D$day==t[i])] / D$bact.green[which(D$Treatment=="Isolated" & D$day==t[i])] )
time <- rep(t[i],72)
size <- D$Size[which(D$Treatment=="Connected" & D$day==t[i])]
lala <- cbind(time,size,LRR)
colnames(lala) <- c("time","size","LRR")
output <- rbind.data.frame(output,lala)
}
dat.lrr <- output %>%
mutate(LRR = as.numeric(as.character(LRR))) %>%
group_by(time) %>%
summarise(mean.lrr = mean(LRR, na.rm=TRUE),
CI = qnorm(0.975) * ( sd(LRR) / sqrt(length(LRR)) ) )
plot(NA,xlim=c(1,4),ylim=c(-1,1),xlab="Exp. time",ylab="ln(patch connected / patch isolated)",xaxt="n")
axis(1,at=1:4,labels=dat.lrr$time)
abline(h=0,lty=3)
arrows(1:4,dat.lrr$mean.lrr + dat.lrr$CI,1:4, dat.lrr$mean.lrr - dat.lrr$CI,angle=90,code=3,length=0.05)
points(dat.lrr$time,dat.lrr$mean.lrr,pch=16)
dat.lrr <- output %>%
filter(time==21) %>% #The previous graph showed that the effect if stronger at day 21
mutate(LRR = as.numeric(as.character(LRR))) %>%
group_by(size) %>%
summarise(mean.lrr = mean(LRR, na.rm=TRUE),
CI = qnorm(0.975) * ( sd(LRR) / sqrt(length(LRR)) ) )
plot(NA,xlim=c(1,4),ylim=c(-1.5,1.5),xlab="Patch size",ylab="ln(patch connected / patch isolated)",xaxt="n")
axis(1,at=1:4,labels=dat.lrr$size)
abline(h=0,lty=3)
arrows(1:4,dat.lrr$mean.lrr + dat.lrr$CI,1:4, dat.lrr$mean.lrr - dat.lrr$CI,angle=90,code=3,length=0.05)
points(dat.lrr$size,dat.lrr$mean.lrr,pch=16)
# Filter data (bacteria were only measured for replicates A and B)
X <- data %>%
filter(day!=0 & Replicate %in% c("A","B")) %>%
mutate(Treatment = as.factor(Treatment),
day = factor(day,levels=c("0","7","15","21","29")),
day.cont = log(as.numeric(as.character(day))),
Size = as.ordered(Size),
centrality = as.numeric(as.character(centrality)),
dist.outlet = as.numeric(as.character(dist.outlet)))
# Run model
Mod1 <- nlme:::lme(log(bact.blue) ~ Size*Treatment + bact.green + day.cont,
random = ~ day|Replicate, data=X,
method="ML",control=lmeControl(optimMethod="BFGS",maxIter=100,opt="optim"))
library(nlme)
# Filter data (bacteria were only measured for replicates A and B)
X <- data %>%
filter(day!=0 & Replicate %in% c("A","B")) %>%
mutate(Treatment = as.factor(Treatment),
day = factor(day,levels=c("0","7","15","21","29")),
day.cont = log(as.numeric(as.character(day))),
Size = as.ordered(Size),
centrality = as.numeric(as.character(centrality)),
dist.outlet = as.numeric(as.character(dist.outlet)))
# Run model
Mod1 <- nlme:::lme(log(bact.blue) ~ Size*Treatment + bact.green + day.cont,
random = ~ day|Replicate, data=X,
method="ML",control=lmeControl(optimMethod="BFGS",maxIter=100,opt="optim"))
# Filter data (bacteria were only measured for replicates A and B)
X1 <- data %>%
filter(day!=0 & Replicate %in% c("A","B")) %>%
mutate(Treatment = as.factor(Treatment),
day = factor(day,levels=c("0","7","15","21","29")),
day.cont = log(as.numeric(as.character(day))),
Size = as.numeric(as.character(Size)),
centrality = as.numeric(as.character(centrality)),
dist.outlet = as.numeric(as.character(dist.outlet)))
# Generate data frame with each predictor to extract predictions
newdat <-  with(X1,
expand.grid(Treatment=unique(Treatment),
Size = c(min(Size),max(Size)),
bact.green=c(min(bact.green),max(bact.green)),
day.cont = c(min(day.cont),max(day.cont)))
)
# Run model
Mod1.1 <- nlme:::lme(log(bact.blue) ~ Size*Treatment + bact.green + day.cont,
random = ~ day|Replicate, data=X1,
method="ML",control=lmeControl(optimMethod="BFGS",maxIter=100,opt="optim"))
ggplot(mapping=aes(x=Size,y=log(bact.blue)),data=X1) +
geom_point(col="blue",alpha=0.5) +
geom_line(data=newdat,aes(y=predict(Mod1.1,newdata=newdat,level=0)),col="red") -> p1
ggplot(mapping=aes(x=Treatment,y=log(bact.blue)),data=X1) +
geom_boxplot(col="blue",alpha=0.5) -> p2
ggplot(mapping=aes(x=day.cont,y=log(bact.blue)),data=X1) +
geom_point(col="blue",alpha=0.5) +
geom_line(data=newdat,aes(y=predict(Mod1.1,newdata=newdat,level=0)),col="red") -> p3
grid.arrange(p1,p2,p3,ncol=3)
